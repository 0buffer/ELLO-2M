
``1-Wire
ONEWIRE RESET pin - Reset the 1-Wire bus 
ONEWIRE WRITE pin, flag, length, data [, data...] - Send a number of bytes 
ONEWIRE READ pin, flag, length, data [, data...] - Get a number of bytes 

Where: 
pin - The Micromite I/O pin to use. It can be any pin capable of digital I/O. 
flag - A combination of the following options: 
1 - Send reset before command 
2 - Send reset after command 
4 - Only send/recv a bit instead of a byte of data 
8 - Invoke a strong pullup after the command (the pin will be set high and open 
drain disabled) 
length - Length of data to send or receive 
data - Data to send or variable to receive. 
The number of data items must agree with the length parameter. 

MM.ONEWIRE 
Returns true if a device was found 

``ABS
ABS( number ) 

Returns the absolute value of the argument 'number' (ie, any negative sign is 
removed and the positive number is returned). 

``ACOS
ACOS( number ) 

Returns the inverse cosine of the argument 'number' in radians. 

``ASC
ASC( string$ ) 

Returns the ASCII code for the first letter in the argument ‘string$’. 

``ASCII
The ASCII Code Table 

Char Dec Oct Hex | Char Dec Oct Hex | Char Dec Oct Hex | Char Dec Oct Hex 
------------------------------------------------------------------------------ 
(nul) 0 0000 0x00 | (sp) 32 0040 0x20 | @ 64 0100 0x40 | ` 96 0140 0x60 
(soh) 1 0001 0x01 | ! 33 0041 0x21 | A 65 0101 0x41 | a 97 0141 0x61 
(stx) 2 0002 0x02 | " 34 0042 0x22 | B 66 0102 0x42 | b 98 0142 0x62 
(etx) 3 0003 0x03 | # 35 0043 0x23 | C 67 0103 0x43 | c 99 0143 0x63 
(eot) 4 0004 0x04 | $ 36 0044 0x24 | D 68 0104 0x44 | d 100 0144 0x64 
(enq) 5 0005 0x05 | % 37 0045 0x25 | E 69 0105 0x45 | e 101 0145 0x65 
(ack) 6 0006 0x06 | & 38 0046 0x26 | F 70 0106 0x46 | f 102 0146 0x66 
(bel) 7 0007 0x07 | ' 39 0047 0x27 | G 71 0107 0x47 | g 103 0147 0x67 
(bs) 8 0010 0x08 | ( 40 0050 0x28 | H 72 0110 0x48 | h 104 0150 0x68 
(ht) 9 0011 0x09 | ) 41 0051 0x29 | I 73 0111 0x49 | i 105 0151 0x69 
(nl) 10 0012 0x0a | * 42 0052 0x2a | J 74 0112 0x4a | j 106 0152 0x6a 
(vt) 11 0013 0x0b | + 43 0053 0x2b | K 75 0113 0x4b | k 107 0153 0x6b 
(np) 12 0014 0x0c | , 44 0054 0x2c | L 76 0114 0x4c | l 108 0154 0x6c 
(cr) 13 0015 0x0d | - 45 0055 0x2d | M 77 0115 0x4d | m 109 0155 0x6d 
(so) 14 0016 0x0e | . 46 0056 0x2e | N 78 0116 0x4e | n 110 0156 0x6e 
(si) 15 0017 0x0f | / 47 0057 0x2f | O 79 0117 0x4f | o 111 0157 0x6f 
(dle) 16 0020 0x10 | 0 48 0060 0x30 | P 80 0120 0x50 | p 112 0160 0x70 
(dc1) 17 0021 0x11 | 1 49 0061 0x31 | Q 81 0121 0x51 | q 113 0161 0x71 
(dc2) 18 0022 0x12 | 2 50 0062 0x32 | R 82 0122 0x52 | r 114 0162 0x72 
(dc3) 19 0023 0x13 | 3 51 0063 0x33 | S 83 0123 0x53 | s 115 0163 0x73 
(dc4) 20 0024 0x14 | 4 52 0064 0x34 | T 84 0124 0x54 | t 116 0164 0x74 
(nak) 21 0025 0x15 | 5 53 0065 0x35 | U 85 0125 0x55 | u 117 0165 0x75 
(syn) 22 0026 0x16 | 6 54 0066 0x36 | V 86 0126 0x56 | v 118 0166 0x76 
(etb) 23 0027 0x17 | 7 55 0067 0x37 | W 87 0127 0x57 | w 119 0167 0x77 
(can) 24 0030 0x18 | 8 56 0070 0x38 | X 88 0130 0x58 | x 120 0170 0x78 
(em) 25 0031 0x19 | 9 57 0071 0x39 | Y 89 0131 0x59 | y 121 0171 0x79 
(sub) 26 0032 0x1a | : 58 0072 0x3a | Z 90 0132 0x5a | z 122 0172 0x7a 
(esc) 27 0033 0x1b | ; 59 0073 0x3b | [ 91 0133 0x5b | { 123 0173 0x7b 
(fs) 28 0034 0x1c | < 60 0074 0x3c | \ 92 0134 0x5c | | 124 0174 0x7c 
(gs) 29 0035 0x1d | = 61 0075 0x3d | ] 93 0135 0x5d | } 125 0175 0x7d 
(rs) 30 0036 0x1e | > 62 0076 0x3e | ^ 94 0136 0x5e | ~ 126 0176 0x7e 
(us) 31 0037 0x1f | ? 63 0077 0x3f | _ 95 0137 0x5f |(del) 127 0177 0x7f 

``ASIN
ASIN( number ) 

Returns the inverse sine value of the argument 'number' in radians. 

``ATN
ATN( number ) 

Returns the arctangent of the argument 'number' in radians. 

``AUTOSAVE
AUTOSAVE 

Enter automatic program entry mode. 
This command will take lines of text from the console serial input and 
save them to memory. This mode is terminated by entering Control-Z which 
will then cause the received data to be saved into program memory overwriting 
the previous program. 
At any time this command can be aborted by Control-C which will leave program 
memory untouched. 
This is one way of transferring a BASIC program into the Micromite. The program 
to be transferred can be pasted into a terminal emulator and this command will 
capture the text stream and store it into program memory. 
It can also be used for entering a small program directly at the console input. 

``BIN$
BIN$( number [, chars]) 

Returns a string giving the binary (base 2) value for the 'number'. 
'chars' is optional and specifies the number of characters in the string with 
zero as the leading padding character(s) 

``BOX
BOX x1, y1, w, h [, lw] [,c][,fill] 

Draws a box starting at x1 and y1 which is w pixels wide and h pixels high on 
the attached LCD panel. 
'lw' is the width of the sides of the box and can be zero. It defaults to 1. 
'c' specifies the colour and defaults to the default foreground colour if not 
specified. 
'fill' is the fill colour. It can be omitted or set to -1 in which case the box 
will not be filled. 

``CFUNCTION
CFUNCTION name type [,type] 
hex [[ hex[...] 
hex [[ hex[...] 
END CFUNCTION 

Defines the binary code for an embedded machine code program module written in C 
or MIPS assembler. 
The module will appear in MMBasic as the command or function 'name' and can be 
used in the same manner as a built- in command or function. 
This command specifies the hex codes for the module. 
This code is automatically programmed into MMBasic when the program is saved. 
- Each 'hex' must be exactly eight hex digits representing the bits in a 32-bit 
word. 
- Each 'hex' word must be separated by one or more spaces and multiplelines of 
'hex' words can be used. 
The command must be terminated by a matching END CFUNCTION. 
- The first 'hex' word must be the offset (in 32-bit words) to the entry point 
of the embedded routine (usually the function main()). 
- Multiple embedded routines can be used in a program with each defining a 
different module with a different 'name'. 
- During execution MMBasic will skip over any CSUB or CFUNCTION commands so they 

can be placed anywhere in the program. 
Any errors in the data format will be reported when the program is saved. 

The type of each parameter can be specified in the definition. For example: 

Csub MySub integer, integer, string 
This specifies that there will be three parameters, the first two being integers 

and the third a string. 
As well as defining the types of the parameters a CFUNCTION can also specify the 

type of the value returned. 
For example, the following returns a string: 

CFUNCTION MyFunct(integer, string) string 

The 'name' created by these commands can be used as a normal command or function 

within MMBasic with a few caveats: 
- Up to ten values can be specified as parameters ('arg1', 'arg2', etc) and they 

will be passed to the embedded C routine as pointers to the memory space 
allocated to each value (ie, the result of the expression). 
- If a variable or array is specified as an argument the C routine will receive 
a pointer to the memory allocated to the variable or array and the C routine can 

change this memory to return a value to the caller. 
- In the case of arrays, they should be passed with empty brackets. Eg, arg(). 
In the C function the argument will be supplied as a pointer to the first 
element of the array. 

``CHR$
CHR$( number ) 

Returns a one-character string consisting of the character corresponding to the 
ASCII code indicated by argument 'number'. 

``CINT
CINT( number ) 

Round numbers with fractional portions up or down to the next whole number or 
integer. 
For example, 
45.47 will round to 45 
45.57 will round to 46 
-34.45 will round to -34 
-34.55 will round to -35 
See also INT() and FIX() 

``CIRCLE
CIRCLE x, y, r [,lw] [, a] [,c] [, fill] 

Draw a circle on the video output centred at 'x' and 'y' with a radius of 'r' on 
the attached LCD panel. 'c' is the optional colour and defaults to the current 
foreground colour if not specified. 
The optional 'a' is a floating point number which will define the aspect ratio. 
If the aspect is not specified the default is 1.0 which gives a standard circle 
'fill' is the fill colour. It can be omitted or set to -1 in which case the box 
will not be filled. 

``CLEAR
CLEAR 

Delete all variables and recover the memory used by them. 
See ERASE for deleting specific array variables. 

``CLOSE
CLOSE [#]nbr [,[#]nbr] ... 

Close the serial communications port(s) previously opened with the file number 
‘nbr’. The # is optional. Also see the OPEN command. 

``CLS
CLS [colour] 

Clears the LCD panel's screen. Optionally 'colour' can be specified which will 
be used for the background when clearing the screen. 

``COLOUR
COLOUR fore [, back] 
COLOR fore [, back] 

Sets the default colour for commands (PRINT, etc) that display on the on the 
attached LCD panel. 
'fore' is the foreground colour 
'back' is the background colour. 
The background is optional and if not specified will default to black. 

``COMMANDS
AUTOSAVE - BOX - CFUNCTION - CIRCLE - CLEAR - CLOSE - CLS - COLOUR - COMMENT - 
CONTINUE - CPU - CPU RESTART - CPU SLEEP - CSUB - DATA - DATE$ - DEFINEFONT - 
DIM - DO - DO LOOP - DO WHILE - EDIT - ELSE - ELSEIF - END - END FUNCTION - END 
SUB - ENDIF - ERASE - ERROR - EXIT - FONT - FOR - FUNCTION - GOSUB - GOTO - GUI 
BITMAP - GUI CALIBRATE - GUI RESET LCDPANEL - GUI TEST - HELP - HUMID - IF - 
INPUT - IR - KEYPAD - LCD - LCD CMD - LET - LIBRARY - LINE - LINE INPUT - LIST - 
LOCAL - LOOP - LOOP - MEMORY - NEW - NEXT - ON ERROR - ON GOTO - ON KEY - OPEN - 
OPTION AUTORUN - OPTION BASE - OPTION BAUDRATE - OPTION BREAK - OPTION CASE - 
OPTION CLOCKTRIM - OPTION COLOURCODE - OPTION CONSOLE - OPTION DEFAULT - OPTION 
DISPLAY - OPTION EXPLICIT - OPTION LCDPANEL - OPTION LIST - OPTION PIN - OPTION 
RESET - OPTION TAB - OPTION TOUCH - PAUSE - PIN - PIXEL - POKE - PORT - PRINT - 
PULSE - PWM - RANDOMIZE - RBOX - READ - REM - RESTORE - RETURN - RTC - RUN - 
SELECT CASE - SERVO - SETPIN - SETTICK - SUB - TEMPR START - TEXT - TIME$ - 
TIMER - TRACE - VAR - WATCHDOG - XMODEM 

``COMMENT
' (single quotation mark) 

Starts a comment and any text following it will be ignored. Comments can be 
placed anywhere on a line. 

``CONTINUE
CONTINUE 
CONTINUE DO 
CONTINUE FOR 

CONTINUE 
Resume running a program that has been stopped by an END statement, an error, or 

CTRL-C. The program will restart with the next statement following the previous 
stopping point. 

CONTINUE DO / CONTINUE FOR 

Skip to the end of a DO/LOOP or a FOR/NEXT loop. The loop condition will then be 

tested and if still valid the loop will continue with the next iteration. 

``COS
COS( number ) 

Returns the cosine of the argument 'number' in radians. 

``CPU
CPU speed 

Set the clock speed of the processor. 
'speed' is set in Mhz and on the 28/44 pin Micromite it can be either 48, 40, 
30, 20, 10, or 5. 
On the Micromite Plus it can be 120, 100, 80, 60, 48, 40, 30, 20, 10 or 5. 

Current drawn by the chip is proportional to the clock speed, so by halving the 
clock speed the current drain is roughly halved. 
The default speed of the CPU when power is applied is 40 Mhz on the 28/44 pin 
Micromite and 100Mhz on the Micromite Plus. 
When the speed is changed all timing functions in MMBasic will be automatically 
corrected to keep the correct time and the console baud rate will be unchanged. 

The serial communications ports can remain open during the speed change and 
their speed will be adjusted accordingly. 
Note that there may be a glitch while changing speed and some characters may be 
lost or corrupted. 
The speed of any SPI, I 2 C and PWM functions open at the time will change with 
the clock speed. 
For this reason they should be closed before this command is used and reopened 
after. 

``CPU RESTART
CPU RESTART 

Will force a restart of the processor. 
This will clear all variables and reset everything (eg, timers, COM ports, I2C, 
etc) similar to a power up situation but without the power up banner. 

If OPTION AUTORUN has been set the program in memory will restart. 

``CPU SLEEP
CPU SLEEP 
CPU SLEEP seconds 

Put the CPU to sleep. In this mode the running program will be halted and the 
current drain reduced to less than 40 μA. 
In the first form (CPU SLEEP seconds) the command will put the CPU to sleep for 
the specified number of 'seconds' (maximum of 10 days). 
This command will update the TIMER function and internal calendar when it comes 
out of sleep but note that the sleep time is not very accurate; it can vary by 
up to ±20%. 
In the second form the WAKEUP pin (see the pinout tables at the start of this 
manual) will be automatically configured as a digital input and any change in 
its state (ie, from high to low or low to high) will wakeup the CPU. 

The IR command shares the WAKEUP pin and if it is running the CPU will be 
awakened by the remote key press and MMBasic will immediately decode the signal 
and execute the IR interrupt. 

Notes: 
- The CPU will go to sleep in the middle of the SLEEP command and when awakened 
continue with normal program execution. 
- All communications (serial, SPI, I2C and 1-Wire) and PWM will be frozen during 

sleep. When the CPU comes out of sleep they will resume normal processing. It is 

recommended that they be closed before entering sleep as they will add to the 
current drawn by the chip in sleep. 
- The time required to "wake up" is less than 1 mS. 
- External circuitry and program features can cause extra current drain while in 

sleep. 
- All timing functions will freeze during the sleep, this includes the real time 

clock and background pulse commands. 
- CTRL-C on the console will not bring the chip out of sleep. 

``CSUB
CSUB name(type [, type]) rtype 
hex [[ hex[...] 
hex [[ hex[...] 
END CSUB 

Defines the binary code for an embedded machine code program module written in C 
or MIPS assembler. 
The module will appear in MMBasic as the command or function 'name' and can be 
used in the same manner as a built- in command or function. 
This command specifies the hex codes for the module. 
This code is automatically programmed into MMBasic when the program is saved. 
- Each 'hex' must be exactly eight hex digits representing the bits in a 32-bit 
word. 
- Each 'hex' word must be separated by one or more spaces and multiplelines of 
'hex' words can be used. 
The command must be terminated by a matching END CSUB 
- The first 'hex' word must be the offset (in 32-bit words) to the entry point 
of the embedded routine (usually the function main()). 
- Multiple embedded routines can be used in a program with each defining a 
different module with a different 'name'. 
- During execution MMBasic will skip over any CSUB or CFUNCTION commands so they 
can be placed anywhere in the program. 
Any errors in the data format will be reported when the program is saved. 
The type of each parameter can be specified in the definition. For example: 

Csub MySub integer, integer, string 
This specifies that there will be three parameters, the first two being integers 
and the third a string. 
As well as defining the types of the parameters a Cfunction can also specify the 
type of the value returned. For example, the following returns a string: 

CFUNCTION MyFunct(integer, string) string 
The 'name' created by these commands can be used as a normal command or function 
within MMBasic with a few caveats: 
- Up to ten values can be specified as parameters ('arg1', 'arg2', etc) and they 
will be passed to the embedded C routine as pointers to the memory space 
allocated to each value (ie, the result of the expression). 
- If a variable or array is specified as an argument the C routine will receive 
a pointer to the memory allocated to the variable or array and the C routine can 
change this memory to return a value to the caller. 
- In the case of arrays, they should be passed with empty brackets. Eg, arg(). 
In the C function the argument will be supplied as a pointer to the first 
element of the array. 

``DATA
DATA constant[,constant]… 

Stores numerical and string constants to be accessed by READ. 
In general string constants should be surrounded by double quotes ("). 

An exception is when the string consists of just alphanumeric characters 
that do not represent MMBasic keywords (such as THEN, WHILE, etc). 
In that case quotes are not needed. 
Numerical constants can also be expressions such as 5 * 60. 

``DATE$
DATE$ = "DD-MM-YY" 
DATE$ = "DD/MM/YY" 

Set the date of the internal clock/calendar. 
DD, MM and YY are numbers, for example: DATE$ = "28-7-2014" 
The date is set to "1-1-2000" on power up. 

When used as function, DATE$ returns the current date based on MMBasic’s 
internal clock as a string in the form "DD-MM-YYYY". For example, "28-07-2012". 
The internal clock/calendar will keep track of the time and date including leap 
years. 
``DEFINEFONT
DEFINEFONT #Nbr 
hex [[ hex[...] 
hex [[ hex[...] 
END DEFINEFONT 

This will define an embedded font which can be used alongside or to replace 
the built in font(s) used on an attached LCD panel. 
These work exactly same as the built in fonts (ie, selected using the FONT 

command or specified in the TEXT command). 
'#Nbr' is the font's reference number (from 1 to 16). It can be the same 
number as a built in font and in that case it will replace the built in 
font. 
Each 'hex' must be exactly eight hex digits and be separated by spaces 
or new lines from the next. 
- Multiple lines of 'hex' words can be used with the command terminated 
by a matching END DEFINEFONT. 
- Multiple embedded fonts can be used in a program with each defining a 

different font with a different font number. 
- During execution MMBasic will skip over any DEFINEFONT commands so they 
can be placed anywhere in the program. 
- Any errors in the data format will be reported when the program is saved. 

``DEG
DEG( radians ) 

Converts 'radians' to degrees. 

``DIM
DIM [type] decl [,decl]… 

where 'decl' is: 
var [length] [type] [init] 
'var' is a variable name with optional dimensions 
'length' is used to set the maximum size of the string to 'n' as in LENGTH 

n 
'type' is one of AS FLOAT or AS INTEGER or AS STRING 
'init' is the value to initialise the variable and consists of: 
= <expression> 
For a simple variable one expression is used, for an array a list of comma 

separated expressions surrounded by brackets is used. 

Examples: 
DIM nbr(50) 
DIM INTEGER nbr(50) 
DIM name AS STRING 
DIM a, b$, nbr(100), strn$(20) 
DIM a(5,5,5), b(1000) 
DIM strn$(200) LENGTH 20 
DIM STRING strn(200) 
LENGTH 20 
DIM a = 1234, b = 345 
DIM STRING strn = "text" 
DIM x%(3) = (11, 22, 33, 44) 

Declares one or more variables (ie, makes the variable name and its 
characteristics known to the interpreter). 
When OPTION EXPLICIT is used (as recommended) the DIM or LOCAL 
commands are the only way that a variable can be created. If this option 
is not used then using the DIM command is optional and if not used the 
variable will be created automatically when first referenced. 
The type of the variable (ie, string, float or integer) can be specified 
in one of three ways: 
By using a type suffix (ie, !, % or $ for float, integer or string). 

For example: 
DIM nbr%, amount!, name$ 

By using one of the keywords FLOAT, INTEGER or STRING immediately 
after the command DIM and before the variable(s) are listed. The specified 
type then applies to all variables listed (ie, it does not have to be repeated). 
For example: 
DIM AS STRING first_name, last_name, city 
By using the Microsoft convention of using the keyword "AS" and the type 
keyword (ie, FLOAT, INTEGER or STRING) after each variable. If you 
use this method the type must be specified for each variable and can be 
changed from variable to variable. 

For example: 
DIM amount AS FLOAT, name AS STRING 

Floating point or integer variables will be set to zero when created and 
strings will be set to an empty string (ie, ""). You can initialise the 
value of the variable with something different by using an equals symbol (=) and 

an expression following the variable definition. 

For example: 
DIM AS STRING city = "Perth", house = "Brick" 

The initialising value can be an expression (including other variables) 
and will be evaluated when the DIM command is executed. See the chapter 
"Defining and Using Variables" for more examples of the syntax. 
As well as declaring simple variables the DIM command will also declare 
arrayed variables (ie, an indexed variable with a number of dimensions). 
Following the variable's name the dimensions are specified by a list of 
numbers separated by commas and enclosed in brackets. For example: 
DIM array(10, 20) 
Each number specifies the number of elements in each dimension. Normally 
the numbering of each dimension starts at 0 but the OPTION BASE 
command can be used to change this to 1. 
The above example specifies a two dimensional array with 11 elements (0 
to 10) in the first dimension and 21 (0 to 20) in the second dimension. The 
total number of elements is 231 and because each floating point number 
requires 4 bytes a total of 924 bytes of memory will be allocated (integers 
are different and require 8 bytes per element). 
Strings will default to allocating 255 bytes (eg, characters) of memory 
for each element and this can quickly use up memory. In that case the 
LENGTH keyword can be used to specify the amount of memory to be 
allocated to each element and therefore the maximum length of the string 
that can be stored. This allocation ('n') can be from 1 to 255 characters. 
For example: DIM str$(5, 10) will declare a string array with 66 elements 

consuming 16,896 bytes of memory while: 
DIM AS STRING str (5, 10) LENGTH 20 
Will only consume 1,386 bytes of memory. Note that the amount of 
memory allocated for each element is n + 1 as the extra byte is used to 
track the actual length of the string stored in each element. 
If a string longer than 'n' is assigned to an element of the array an error 
will be produced. Other than this string arrays created with the LENGTH 
keyword act exactly the same as other string arrays. Note that the LENGTH 
keyword can also be used when defining non array string variables. 
In the above example you can also use the Microsoft syntax of specifying 
the type after the length specifier. For example: 
DIM str (5, 10) LENGTH 20 AS STRING 
Arrays can also be initialised when they are declared by adding an equals 
symbol (=) followed by a bracketed list of values at the end of the 
declaration. For example: 
DIM INTEGER nbr(4) = (22, 44, 55, 66, 88) 
or 
DIM str$(3) = ("foo", "boo", "doo", "zoo") 
Note that the number of initialising values must match the number of 
elements in the array including the base value set by OPTION BASE. If a 
multi dimensioned array is initialised then the first dimension will be 
initialised first followed by the second, etc. 

``DISTANCE
DISTANCE( trigger, echo ) 
or 
DISTANCE( trig-echo ) 

Measure the distance to a target using the HC-SR04 ultrasonic distance sensor. 
Four pin sensors have separate trigger and echo connections. 'trigger' is the 
I/O pin connected to the "trig" input of the sensor and 'echo' is the pin 
connected to the "echo" output of the sensor. 
Three pin sensors have a combined trigger and echo connection and in that case 
you only need to specify one I/O pin to interface to the sensor. 
Note that any I/O pins used with the HC-SR04 should be 5V capable as the HC-SR04 
is a 5V device. The I/O pins are automatically configured by this function and 
multiple sensors can be used on different I/O pins. 

The value returned is the distance in centimetres to the target or -1 if no 
target was detected or -2 if there was an error (ie, sensor not connected). 
The CPU speed must be 10 MHz or higher and the measurement can take up to 32 mS 
to complete. 

``DO
DO 
<statements> 
LOOP 

This structure will loop forever; the EXIT DO command can be used to terminate 

the loop or control must be explicitly transferred outside of the loop 
by commands like GOTO or RETURN (if in a subroutine). 

``DO LOOP
DO 
<statements> 
LOOP UNTIL expression 

Loops until the expression following UNTIL is true. Because the test is 
made at the end of the loop the statements inside the loop will be executed 
at least once, even if the expression is true. 

``DO WHILE
DO WHILE expression 
<statements> 
LOOP 

Loops while "expression" is true (this is equivalent to the older WHILE-WEND 

loop, also implemented in MMBasic). If, at the start, the expressionis 
false the statements in the loop will not be executed, even once. 

``EDIT
EDIT 

Invoke the full screen editor. 

All the editing keys work with a VT100 terminal emulator so editing can also be 
accomplished over the console serial link. The editor has been tested with Tera 
Term and PuTTY running on a Windows PC. 
On entry the cursor will be automatically positioned at the last line edited or, 

if there was an error when running the program, the line that caused the error. 
The editing keys are: 
Left/Right arrows - Moves the cursor within the line. 
Up/Down arrows - Moves the cursor up or down a line. 
Page Up/Down - Move up or down a page of the program. 
Home/End - Moves the cursor to the start or end of the line. A second Home/End 
will move to the start or end of the program. 
Delete - Delete the character over the cursor. This can be the line separator 
character and thus join two lines. 
Backspace - Delete the character before the cursor. 
Insert - Will switch between insert and overtype mode. 
Escape - Key Will close the editor without saving (confirms first). 
F1 - Save the edited text and exit. 
F2 - Save, exit and run the program. 
F3 Invoke the search function. 
SHIFT F3 - Repeat the search using the text entered with F3. 
F4 - Mark text for cut or copy (see below). 
F5 – Paste text previously cut or copied. 

When in the mark text mode (entered with F4) the editor will allow you to use 
the arrow keys to highlight text which can be deleted, cut to the clipboard or 
simply copied to the clipboard. 
The status line will change to indicate the new functions of the function keys. 
The editor will work with lines wider than the screen but characters beyond the 
screen edge will not be visible. You can split such a line by inserting a new 
line character and the two lines can be later rejoined by deleting the inserted 
new line character. 

``ELSE
ELSE 

Introduces a default condition in a multiline IF statement. See the multiline 
IF statement for more details. 

``ELSEIF
ELSEIF expression THEN 
ELSE IF expression THEN 

Introduces a secondary condition in a multiline IF statement. See the multiline 
IF statement for more details. 

``END
END 

End the running program and return to the command prompt. 

``END FUNCTION
END FUNCTION 

Marks the end of a user defined function. See the FUNCTION command. 
Each function must have one and only one matching END FUNCTION statement. 

Use EXIT FUNCTION if you need to return from a function from within its body. 

``END SUB
END SUB 

Marks the end of a user defined subroutine. See the SUB command. 
Each sub must have one and only one matching END SUB statement. 
Use EXIT SUB if you need to return from a subroutine from within its body. 


``ENDIF
ENDIF 
END IF 

Terminates a multiline IF statement. See the multiline IF statement for more 
details. 

``EOF
EOF( [#]nbr ) 

For a serial communications port this function will return true if there are no 
characters waiting in the receive buffer. #0 can be used which refers to the 
console's input buffer. 
The # is optional. Also see the OPEN, INPUT and LINE INPUT commands and the 
INPUT$ function. 

``ERASE
ERASE variable [,variable]… 

Deletes arrayed variables and frees up the memory. 
Use CLEAR to delete all variables including all arrayed variables. 

``ERROR
ERROR [error_msg$] 

Forces an error and terminates the program. 
This is normally used in debugging or to trap events that should not occur. 

``EXIT
EXIT DO 
EXIT FOR 
EXIT FUNCTION 
EXIT SUB 

EXIT DO provides an early exit from a DO...LOOP 
EXIT FOR provides an early exit from a FOR...NEXT loop. 
EXIT FUNCTION provides an early exit from a defined function. 
EXIT SUB provides an early exit from a defined subroutine. 
The old standard of EXIT on its own (exit a do loop) is also supported. 

``EXP
EXP( number ) 

Returns the exponential value of 'number'. 

``FIX
FIX( number ) 

Truncate a number to a whole number by eliminating the decimal point and all 
characters to the right of the decimal point. 
For example 9.89 will return 9 and -2.11 will return -2. 
The major difference between FIX and INT is that FIX provides a true integer 
function (ie, does not return the next lower number for negative numbers as 
INT() does). This behaviour is for Microsoft compatibility. 
See also CINT() . 

``FONT
FONT [#]font-number, scaling 

This will set the default font for displaying text on an LCD panel. 
Fonts are specified as a number. For example, #2 (the # is optional) 
'scaling' can range from 1 to 15 and will multiply the size of the pixels making 

the displayed character correspondingly wider and higher. Eg, a scale of 2 will 
double the height and width. 

``FOR
FOR counter = start TO finish 
[STEP increment] 

Initiates a FOR-NEXT loop with the 'counter' initially set to 'start' and 
incrementing in 'increment' steps (default is 1) until 'counter' equals 
'finish'. 
The ‘increment’ can be an integer or floating point number. Note that using a 
floating point fractional number for 'increment' can accumulate rounding errors 
in 'counter' which could cause the loop to terminate early or late. 
'increment' can be negative in which case 'finish' should be less than 'start' 
and the loop will count downwards. 
See also the NEXT command. 

``FUNCTION
FUNCTION xxx (arg1 
[,arg2, ...]) [AS <type>} 
<statements> 
<statements> 
xxx = <return value> 
END FUNCTION 

Defines a callable function. 
This is the same as adding a new function to MMBasic while it is running your 
program. 
'xxx' is the function name and it must meet the specifications for naming a 
variable. 
The type of the function can be specified by using a type suffix (ie, xxx$) or 
by specifying the type using AS <type> at the end of the functions definition. 

For example: 
FUNCTION xxx (arg1, arg2) AS STRING 
'arg1', 'arg2', etc are the arguments or parameters to the function. 
An array is specified by using empty brackets. ie, arg3(). 
The type of the argument can be specified by using a type suffix (ie, arg1$) or 
by specifying the type using AS <type> (ie, arg1 AS STRING). 
The argument can also be another defined function or the same function if 
recursion is to be used (the recursion stack is limited to 50 nested calls). 
To set the return value of the function you assign the value to the function's 
name. 

For example: 
FUNCTION SQUARE(a) 
SQUARE = a * a 
END FUNCTION 

Every definition must have one END FUNCTION statement. 
When this is reached the function will return its value to the expression from 
which it was called. 
The command EXIT FUNCTION can be used for an early exit. 
You use the function by using its name and arguments in a program just as you 
would a normal MMBasic function. 

For example: 
PRINT SQUARE(56.8) 

When the function is called each argument in the caller is matched to the 
argument in the function definition. 
These arguments are available only inside the function. 
Functions can be called with a variable number of arguments. 
Any omitted arguments in the function's list will be set to zero or a null 
string. 
Arguments in the caller's list that are a variable (ie, not an expression or 
constant) will be passed by reference to the function. 
This means that any changes to the corresponding argument in the function will 
also be copied to the caller's variable. 
Arrays are passed by specifying the array name with empty brackets (eg, arg()) 
and are always passed by reference. 
You must not jump into or out of a function using commands like GOTO, GOSUB, 
etc. 
Doing so will have undefined side effects including the possibility of ruining 
your day. 

``FUNCTIONS
ABS - ACOS - ASC - ASIN - ATN - BIN$ - CHR$ - CINT - COS - DEG - DISTANCE - EOF 
- EXP - FIX - HEX$ - INKEY$ - INPUT$ - INSTR - INT - LCASE$ - LEFT$ - LEN - LOC 
- LOF - LOG - MID$ - OCT$ - PEEK - PI - POS - PULSIN - RAD - RGB - RIGHT$ - RND 
- SGN - SIN - SPACE$ - SQR - STR$ - STRING$ - TAB - TAN - TEMPR - TOUCH - UCASE$ 
- VAL 

``GOSUB
GOSUB target 

Initiates a subroutine call to the target, which can be a line number or a 
label. 
The subroutine must end with RETURN. 

``GOTO
GOTO target 

Branches program execution to the target, which can be a line number or a label. 


``GUI BITMAP
GUI BITMAP x, y, bits [,width] [, height] [, scale] [, c][, bc] 

Displays the bits in a bitmap on an LCD panel starting at 'x' and 'y' on an 
attached LCD panel. 
'height' and 'width' are the dimensions of the bitmap as displayed on the LCD 
panel and default to 8x8. 
'scale' is optional and defaults to that set by the FONT command. 'c' is the 
drawing colour and 'bc' is the background colour. 
They are optional and default to the current foreground and background colours. 
The bitmap can be an integer or a string variable or constant and is drawn using 

the first byte as the first bits of the top line (bit 7 first, then bit 6, etc) 
followed by the next byte, etc. 
When the top line has been filled the next line of the displayed bitmap will 
start with the next bit in the integer or String. 

``GUI CALIBRATE
GUI CALIBRATE 

This command is used to calibrate the touch feature on an LCD panel. 
It will display a series of targets on the screen and wait for each one to be 
precisely touched. 

``GUI RESET LCDPANEL
GUI RESET LCDPANEL 

Will reinitialise the configured LCD panel. 
Initialisation is automatically done when the Micromite starts up but in some 
circumstances it may be necessary to interrupt power to the LCD panel (eg, to 
save battery power) and this command can then be used to reinitialise the 
display. 

``GUI TEST
GUI TEST TOUCH 
GUI TEST LCDPANEL 

Will test the display or touch feature on an LCD panel. 
With GUI TEST LCDPANEL an animated display of colour circles will be rapidly 
drawn on top of each other. 
With GUI TEST TOUCH the screen will blank and wait for a touch which will cause 
a white dot to be placed on the display marking the touch position on the 
screen. 

``HELP
HELP topic 

MMZ Module Help File 

The help information resides in a single file MMZHELP.TXT which must be located 
in the root folder of drive A: 

One can bring up any file by simply typing 'help whatever' no (' or ") are 
required but can be used and the file will come on the screen and not interrupt 
the program in memory. 
All file names are in lower case. 

Example 

\>help pause 

Will show the "pause" command, then go back to the command prompt. 

There are some help files where the name is a reserved keyword in MMBasic so if 
one ends up with the main help screen after pressing enter try using a (") 
Double Quote in front of the help word. 

Below are a list of the major help pages and one just needs to type the word 
into the help. T a minor spelling error is done the Help file system will 
possibly find the relevant file aswell. 

- Editor :- Explains the use of the online Editor 
- Commands :- Lists all of the Commands used 
- Functions:- Lists all of the Functions used. 
- Revision Changes - for The Module :- This includes new commands 
- Serial Communications 
- I2C Communications 
- SPI Communications 
- One Wire 
- Interrupts 
- Loadable Fonts 
- Operators and Precendence :- typing operator Will start this file 
- Deprecated Commands 
- ASCII-DEC-OCT-HEX table 
- Defined Subroutines and Functions 
- Multithreading and other specific to ELLO commands and functions 

``HEX$
HEX$( number [, chars]) 

Returns a string giving the hexadecimal (base 16) value for the 'number'. 
'chars' is optional and specifies the number of characters in the string with 
zero as the leading padding character(s) 

``HUMID
HUMID pin, tvar, hvar 

Returns the temperature and humidity using the DHT22 sensor. 
Alternative versions of the DHT22 are the AM2303 or the RHT03 (all are 
compatible). 
'pin' is the I/O pin connected to the sensor. Any I/O pin may be used. 
'tvar' is the variable that will hold the measured temperature and 'hvar' is the 

same for humidity. 
Both must be present and both must be floating point variables. 

For example: HUMID 2, TEMP!, HUMIDITY! 

Temperature is measured in oC and the humidity is percent relative humidity. 

Both will be measured with a resolution of 0.1. If an error occurs (sensor not 
connected or corrupt signal) both values will be 1000.0. 
The CPU speed must be 10MHz or higher and the measurement will take 6ms to 
complete. 
Normally the signal pin of the DHT22 should be pulled up by a 1K to 10K resistor 

(4.7K recommended) to the supply voltage. 
The Micromite will also enable an internal high value pullup resistor so when 
the cable length is short (under 30cm) the external pullup resistor may be 
omitted. 

``I2C
I2C OPEN speed, timeout [, PU] 
I2C WRITE addr, option, sendlen, senddata [,sendata ....] 
I2C READ addr, option, rcvlen, rcvbuf 
I2C CLOSE 

I2C SLAVE OPEN addr, mask, option, send_int, rcv_int 
I2C SLAVE WRITE sendlen, senddata [,sendata ....] 
I2C SLAVE READ rcvlen, rcvbuf, rcvd 
I2C SLAVE CLOSE 

MM.I2C 

``I2C CLOSE
I2C CLOSE 

Disables the slave I 2 C module and returns the I/O pins to a "not configured" 
state. Then can then be configured using SETPIN. This command will also send a 
stop if the bus is still held. 

``I2C OPEN
I2C OPEN speed, timeout [, PU] 

Enables the I 2 C module in master mode. 
‘speed’ is a value between 10 and 400 (for bus speeds 10 kHz to 400 kHz). 
‘timeout’ is a value in milliseconds after which the master send and receive 
commands will be interrupted if they have not completed. The minimum value is 
100. A value of zero will disable the timeout (though this is not recommended). 
'PU' (if specified) will enable weak pullups (about 100K) on both the clock and 
data lines. I 2 C normally requires lower value resistors (typically 10K) but 
for short signal lines at slow speed this may be all that is required. 

``I2C READ
I2C READ addr, option, rcvlen, rcvbuf 

Get data from the I 2 C slave device. 
‘addr’ is the slave I 2 C address. 
‘option’ is a number between 0 and 3 (normally this is set to 0) 
1 = keep control of the bus after the command (a stop condition will not be sent 
at the completion of the command) 
2 = treat the address as a 10 bit address 
3 = combine 1 and 2 (hold the bus and use 10 bit addresses). 
‘rcvlen’ is the number of bytes to receive. 
‘rcvbuf’ is the variable to receive the data - this can be a string variable 
(eg, t$), or a one dimensional array of numbers specified without the dimensions 
(eg, data()) or a normal numeric variable (in this case rcvlen must be 1). 

``I2C SLAVE CLOSE
I2C SLAVE CLOSE 

Disables the slave I 2 C module and returns the external I/O pins 12 and 13 to a 
"not configured" state. Then can then be configured using SETPIN. 

``I2C SLAVE OPEN
I2C SLAVE OPEN 

Enables the I 2 C module in slave mode. 
‘addr’ is the slave I 2 C address. 
‘mask’ is the address mask (normally 0, bits set as 1 will always match). 
This allows the slave to respond to multiple addresses. 
‘option’ is a number between 0 and 3 (normally this is set to 0). 
1 = allows MMBasic to respond to the general call address. When this occurs the 
value of MM.I2C will be set to 4. 
2 = treat the address as a 10 bit address 
3 = combine 1 and 2 
‘send_int’ is the subroutine to be invoked when the module has detected that the 
master is expecting data. 
‘rcv_int is the subroutine to be called when the module has received data from 
the master. Note that this is triggered on the first byte received so your 
program might need to wait until all the data is received. 

``I2C SLAVE READ
I2C SLAVE READ rcvlen, rcvbuf, rcvd 

Receive data from the I 2 C master device. This command should be used in the 
receive interrupt (ie in the 'rcv_int' subroutine when the master has sent some 
data). Alternatively a flag can be set in the receive interrupt subroutine and 
the command invoked from the main program loop when the flag is set. 
‘rcvlen’ is the maximum number of bytes to receive. 
‘rcvbuf’ is the variable to receive the data - this can be a string variable 
(eg, t$), or a one dimensional array of numbers specified without the dimensions 
(eg, data()) or a normal numeric variable (in this case rcvlen must be 1). 
‘rcvd’ will contain the actual number of bytes received by the command. 

``I2C SLAVE WRITE
I2C SLAVE WRITE sendlen, senddata [,sendata....] 

Send the data to the I 2 C master. This command should be used in the send 
interrupt (ie in the 'send_int' subroutine when the master has requested data). 
Alternatively a flag can be set in the interrupt subroutine and the command 
invoked from the main program loop when the flag is set. 
‘sendlen is the number of bytes to send. 
‘senddata’ is the data to be sent. This can be specified in various ways, see 
the I2C WRITE commands for details. 

``I2C WRITE
I2C WRITE addr, option, sendlen, senddata [,sendata ....] 

Send data to the I 2 C slave device. 
‘addr’ is the slave I 2 C address. 
‘option’ is a number between 0 and 3 (normally this is set to 0) 
1 = keep control of the bus after the command (a stop condition will not 
be sent at the completion of the command) 
2 = treat the address as a 10 bit address 
3 = combine 1 and 2 (hold the bus and use 10 bit addresses). 
‘sendlen’ is the number of bytes to send. 
‘senddata’ is the data to be sent - this can be specified in various ways (all 
values sent will be between 0 and 255): 
 The data can be supplied in the command as individual bytes. 
Example: I2C WRITE &H6F, 1, 3, &H23, &H43, &H25 
 The data can be in a one dimensional array specified with empty brackets (ie, 
no dimensions). The data will be written starting with the first element. 
Example: I2C WRITE &H6F, 1, 3, ARRAY() 
 The data can be a string variable (not a constant). 
Example: I2C WRITE &H6F, 1, 3, STRING$ 

``IF
IF expr THEN statement 
or 
IF expr THEN stmt ELSE stmt 
or 
IF expression THEN 
<statements> 
[ELSEIF expression THEN 
<statements>] 
[ELSE 
<statements>] 
ENDIF 

Evaluates the expression ‘expr' and performs the THEN statement if it is true or 

skips to the next line if false. 
The optional ELSE statement is the reverse of the THEN test. 
This type of IF statement is all on one line. 
The ‘THEN statement’ construct can be also replaced with: 

GOTO linenumber | label’. 

Multiline IF statement with optional ELSE and ELSEIF cases and ending with 
ENDIF. 
Each component is on a separate line. 
Evaluates 'expression' and performs the statement(s) following THEN if the 
expression is true or optionally the statement(s) following the ELSE statement 
if false. 
The ELSEIF statement (if present) is executed if the previous condition is false 

and it starts a new IF chain with further ELSE and/or ELSEIF statements as 
required. 
One ENDIF is used to terminate the multiline IF. 

``INKEY$
INKEY$ 

Checks the console input buffers and, if there is one or more characters waiting 
in the queue, will remove the first character and return it as a single 
character in a string. 
If the input buffer is empty this function will immediately return with an empty 
string (ie, "") 

``INPUT
INPUT ["prompt string$";] list of variables 
INPUT #nbr, list of variables 

Allows input to a list of variables 
Either from the console or from a serial port previously opened for INPUT as 
‘nbr’ (See the OPEN command). 

The console input command will prompt with a question mark (?). 
The input must contain commas to separate each data item if there is more than 
one variable. 

For example, if the command is: 
INPUT a, b, c 
And the following is typed on the keyboard: 23, 87, 66 
Then a = 23 and b = 87 and c = 66 

If the "prompt string$" is specified it will be printed before the question 
mark. 
If the prompt string is terminated with a comma (,) rather than the semicolon 
(;) the question mark will be suppressed. 

``INPUT$
INPUT$(nbr, [#]fnbr) 

Will return a string composed of ‘nbr’ characters read from a serial 
communications port opened as 'fnbr'. This function will return as many 
characters as are waiting in the receive buffer up to ‘nbr’. If there are no 
characters waiting it will immediately return with an empty string. 
#0 can be used which refers to the console's input buffer. 
The # is optional. Also see the OPEN command. 

``INSTR
INSTR( [start-position,] stringsearched$, string-pattern$ ) 

Returns the position at which 'string-pattern$' occurs in 'string-searched$', 
beginning at 'start-position'. 
Both the position returned and 'start-position' use 1 for the first character, 2 
for the second, etc. The function returns zero if 'string-pattern$' is not 
found. 

``INT
INT( number ) 

Truncate an expression to the next whole number less than or equal to the 
argument. For example 9.89 will return 9 and -2.11 will return -3. 
This behaviour is for Microsoft compatibility, the FIX() function provides a 
true integer function. 
See also CINT() . 

``IR
IR dev, key , int 
or 
IR CLOSE 

Decodes NEC or Sony infrared remote control signals. 
An IR Receiver Module is used to sense the IR light and demodulate the signal. 
It should be connected to the IR pin (see the pinout tables). 
This command will automatically set that pin to an input. 
The IR signal decode is done in the background and the program will continue 
after this command without interruption. 'dev' and 'key' should be numeric 
variables and their values will be updated whenever a new signal is received 
('dev' is the device code transmitted by the remote and 'key' is the key 
pressed). 
'int' is a user defined subroutine that will be called when a new key press is 
received or when the existing key is held down for auto repeat. 
In the interrupt subroutine the program can examine the variables 'dev' and 
'key' and take appropriate action. 
The IR CLOSE command will terminate the IR decoder and return the I/O pin to a 
not configured state. 
Note that for the NEC protocol the bits in 'dev' and 'key' are reversed. 

For example, in 'key' bit 0 should be bit 7, bit 1 should be bit 6, etc. 
This does not affect normal use but if you are looking for a specific numerical 
code provided by a manufacturer you should reverse the bits. This describes how 
to do it: http://www.thebackshed.com/forum/forum_posts.asp?TID=8367 

``KEYPAD
KEYPAD var, int, r1, r2, r3, r4, 
c1, c2, c3 [, c4] 
or 
KEYPAD CLOSE 

Monitor and decode key presses on a 4x3 or 4x4 keypad. 
Monitoring of the keypad is done in the background and the program will continue 

after this command without interruption. 'var' should be a numeric variable and 
its value will be updated whenever a key press is detected. 
'int' is a user defined subroutine that will be called when a new key press is 
received. In the interrupt subroutine the program can examine the variable 'var' 

and take appropriate action. 
r1, r2, r3 and r4 are pin numbers used for the four row connections to the 
keypad and c1, c2, c3 and c4 are the column connections. c4 is optional and is 
only used with 4x4 keypads. This command will automatically configure 
these pins as required. 
On a key press the value assigned to 'var' is the number of a numeric key (eg, 
'6' will return 6) or 10 for the * key and 11 for the # key. On 4x4 keypads the 
number 20 will be returned for A, 21 for B, 22 for C and 23 for D. 
The KEYPAD CLOSE command will terminate the keypad function and return the I/O 
pin to a not configured state. 


``LCASE$
LCASE$( string$ ) 

Returns ‘string$’ converted to lowercase characters. 

``LCD
LCD INIT d4, d5, d6, d7, rs, en 
or 
LCD line, pos, text$ 
or 
LCD CLEAR 
or 
LCD CLOSE 

Display text on an LCD character display module. This command will work with 
most 1-line, 2-line or 4-line LCD modules that use the KS0066, HD44780 or 
SPLC780 controller (however this is not guaranteed). 
The LCD INIT command is used to initialise the LCD module for use. 'd4' to 'd7' 
are the I/O pins that connect to inputs D4 to D7 on the LCD module (inputs D0 to 
D3 should be connected to ground). 'rs' is the pin connected to the register 
select input on the module (sometimes called CMD). 'en' is the pin connected to 
the enable or chip select input on the module. The R/W input on the module 
should always be grounded. The above I/O pins are 
automatically set to outputs by this command. 
When the module has been initialised data can be written to it using the LCD 
command. 'line' is the line on the display (1 to 4) and 'pos' is the character 
location on the line (the first location is 1). 'text$' is a string containing 
the 
text to write to the LCD display. 
'pos' can also be C8, C16, C20 or C40 in which case the line will be cleared 
and the text centred on a 8 or 16, 20 or 40 line display. For example: 
LCD 1, C16, "Hello" 
LCD CLEAR will erase all data displayed on the LCD and LCD CLOSE will terminate 
the LCD function and return all I/O pins to the not configured state. 

``LCD CMD
LCD CMD d1 [, d2 [, etc]] 
or 
LCD DATA d1 [, d2 [, etc]] 

These commands will send one or more bytes to an LCD display as either a command 
(LCD CMD) or as data (LCD DATA). Each byte is a number between 0 and 255 and 
must be separated by commas. The LCD must have 
been previously initialised using the LCD INIT command (see above). 
These commands can be used to drive a non standard LCD in "raw mode" or they can 
be used to enable specialised features such as scrolling, cursors and custom 
character sets. You will need to refer to the data sheet for your LCD to find 
the necessary command and data values. 

``LEFT$
LEFT$( string$, nbr ) 

Returns a substring of ‘string$’ with ‘nbr' of characters from the left 
(beginning) of the string 

``LEN
LEN( string$ ) 

Returns the number of characters in 'string$' 

``LET
LET variable = expression 

Assigns the value of 'expression' to the variable. LET is automatically assumed 
if a statement does not start with a command. 


``LIBRARY
LIBRARY SAVE 
or 
LIBRARY DELETE 
or 
LIBRARY LIST 

The library is a special segment of program memory that can contain program code 
such as subroutines, functions and CFunctions. These routines are not visible to 
the programmer but are available to any program 
running on the Micromite and act the same as built in commands and functions in 
MMBasic. 
LIBRARY SAVE will take whatever is in normal program memory, compress it (remove 
redundant data such as comments) and append it to the library area (main program 
memory is then empty). The code in the library 
will not show in LIST or EDIT and will not be deleted when a new program is 
loaded or NEW is used. 
LIBRARY DELETE will remove the library and recover the memory used. 
LIBRARY LIST will list the contents of the library. 
Note that any code in the library that is not contained within a subroutine or 
function will be executed immediately before a program is run. This can be used 
to initialise constants, set options, etc. 

``LINE
LINE x1, y1, x2, y2 [, LW [, C]] 

Draws a line starting at the coordinates ‘x1’ and ‘y1’ and ending at ‘x2’ and 
‘y2’. 
‘LW’ is the line’s width and is only valid for horizontal or vertical lines. 
It defaults to 1 if not specified or if the line is a diagonal. 
‘C’ is an integer representing the colour and defaults to the current foreground 
colour. 

``LINE INPUT
LINE INPUT [prompt$,] 
string-variable$ 

LINE INPUT #nbr, 
string-variable$ 

Reads an entire line from the console input into ‘string-variable$’. 
If specified the ‘prompt$’ will be printed first. 
Unlike INPUT, this command will read a whole line, not stopping for comma 
delimited data items. 
A question mark is not printed unless it is part of ‘prompt$’. 

LINE INPUT #nbr is same as above except that the input is read from a serial 
communications port previously opened for INPUT as ‘nbr’. See the OPEN command. 
``LIST
LIST 
or 
LIST ALL 

List a program on the serial console. 
LIST on its own will list the program with a pause at every screen full. 
LIST ALL will list the program without pauses. 
This is useful if you wish to transfer the program in the Micromite to a 
terminal emulator on a PC that has the ability to capture its input stream to a 
file. 

``LOC
LOC( [#]fnbr ) 

For a serial communications port opened as 'fnbr' this function will return the 
number of bytes received and waiting in the receive buffer to be read. 
#0 can be used which refers to the console's input buffer. 
The # is optional. 

``LOCAL
LOCAL variable [, variables] 
See DIM for the full syntax. 

Defines a list of variable names as local to the subroutine or function. 
This command uses exactly the same syntax as DIM and will create variables that 
will only be visible within the subroutine or function. They will be 
automatically discarded when the subroutine or function exits. 

``LOF
LOF( [#]fnbr ) 

For a serial communications port opened as 'fnbr' this function will return the 
space (in characters) remaining in the transmit buffer. 
Note that when the buffer is full MMBasic will pause when adding a new character 
and wait for some space to become available. 
The # is optional. 

``LOG
LOG( number ) 

Returns the natural logarithm of the argument 'number'. 

``LOOP
DO 
<statements> 
LOOP 

This structure will loop forever; the EXIT DO command can be used to 
terminatethe loop or control must be explicitly transferred outside of the loop 
by commands like GOTO or RETURN (if in a subroutine). 

``LOOP
LOOP [UNTIL expression] 

Terminates a program loop: see DO. 

``MEMORY
MEMORY 

List the amount of memory currently in use. 
Notes: 
 General memory is used by serial I/O buffers, etc. 
 Program memory is cleared by the NEW command. 
 Variables and the general memory spaces are cleared by many commands (eg, NEW, 
RUN, etc) as well as the specific commands CLEAR and ERASE. 
 Memory usage is rounded to the nearest 1K byte. 
 When a program is loaded it is first buffered in RAM which limits the maximum 
program size. 
MMBasic tokenises the program when it is stored in flash so the final size in 
flash might vary from this. 

``MID$
MID$( string$, start ) 
or 
MID$( string$, start, nbr ) 

Returns a substring of ‘string$’ beginning at ‘start’ and continuing for ‘nbr’ 
characters. The first character in the string is number 1. 
If ‘nbr’ is omitted the returned string will extend to the end of ‘string$' 

``MM.DEVICE$
MM.DEVICE$ 

A string representing the device or platform that MMBasic is running on. 
Currently this variable will contain one of the following: 
"Maximite" on the standard Maximite and compatibles. 
"Colour Maximite" on the Colour Maximite and UBW32. 
"DuinoMite" when running on one of the DuinoMite family. 
"DOS" when running on Windows in a DOS box. 
"Generic PIC32" for the generic version of MMBasic on a PIC32. 
"Micromite" on the PIC32MX150/250 
"Micromite MkII" on the PIC32MX170/270 
"Micromite Plus" on the PIC32MX470 
"Micromite Extreme" on the PIC32MZ series 

``MM.ERRMSG$
MM.ERRNO 
MM.ERRMSG$ 
If a statement caused an error which was ignored these variables will be set 
accordingly. MM.ERRNO is a number where non zero means that there was an error 
and MM.ERRMSG$ is a string representing the error message that 
would have normally been displayed on the console. They are reset to zero and an 
empty string by RUN, ON ERROR IGNORE or ON ERROR SKIP. 

``MM.ERRNO
MM.ERRNO 
MM.ERRMSG$ 

If a statement caused an error which was ignored these variables will be set 
accordingly. MM.ERRNO is a number where non zero means that there was an error 
and MM.ERRMSG$ is a string representing the error message that would have 
normally been displayed on the console. They are reset to zero and an empty 
string by RUN, ON ERROR IGNORE or ON ERROR SKIP. 

``MM.FONTHEIGHT
MM.FONTHEIGHT 
MM.FONTWIDTH 

Integers representing the height and width of the current font (in pixels). 

``MM.FONTWIDTH
MM.FONTHEIGHT 
MM.FONTWIDTH 

Integers representing the height and width of the current font (in pixels). 

``MM.HRES
MM.HRES 
MM.VRES 
Integers representing the horizontal and vertical resolution of the LCD display 
panel (if configured) in pixels. 

``MM.I2C
MM.I2C 

Following an I 2 C write or read command the automatic variable MM.I2C will be 
set to indicate the result of the operation as follows: 
0 = The command completed without error. 
1 = Received a NACK response 
2 = Command timed out 

``MM.ONEWIRE
MM.ONEWIRE 

Following a 1-Wire reset function this integer variable will be set to indicate 
the result of the operation as follows: 
0 = Device not found. 
1 = Device found 

``MM.VER
MM.VER 

The version number of the firmware as a floating point number in the form 
aa.bbcc where aa is the major version number, bb is the minor version number and 
cc is the revision number. For example version 5.03.00 will return 5.3 and 
version 5.03.01 will return 5.0301. 

``MM.VRES
MM.HRES 
MM.VRES 
Integers representing the horizontal and vertical resolution of the LCD display 
panel (if configured) in pixels. 

``MM.WATCHDOG
MM.WATCHDOG 

An integer which is true if MMBasic was restarted as the result of a Watchdog 
timeout (see the WATCHDOG command). False if MMBasic started up normally. 

``NEW
NEW 

Deletes the program in flash and clears all variables. 

``NEXT
NEXT [counter-variable] [,counter-variable], etc 

NEXT comes at the end of a FOR-NEXT loop; see FOR. 
The ‘counter-variable’ specifies exactly which loop is being operated on. 
If no ‘counter-variable’ is specified the NEXT will default to the innermost 
loop. 
It is also possible to specify multiple counter-variables as in: NEXT x, y, z 

``OCT$
OCT$( number [, chars]) 

Returns a string giving the octal (base 8) representation of 'number'. 
'chars' is optional and specifies the number of characters in the string with 
zero as the leading padding character(s). 

``ON ERROR
ON ERROR ABORT 
or 
ON ERROR IGNORE 
or 
ON ERROR SKIP [nn] 
or 
ON ERROR CLEAR 

This controls the action taken if an error occurs while running a program and 
applies to all errors discovered by MMBasic including syntax errors, wrong data, 
missing hardware, etc. 
ON ERROR ABORT will cause MMBasic to display an error message, abort the program 
and return to the command prompt. This is the normal behaviour of MMBasic and is 
the default when a program starts running. 
ON ERROR IGNORE will cause any error to be ignored. 
ON ERROR SKIP will ignore an error in a number of commands (specified by the 
number 'nn') executed following this command. 'nn' is optional, the default if 
not specified is one. After the number of commands has completed (with an error 
or not) the behaviour of MMBasic will revert to ON ERROR ABORT. 
If an error occurs and is ignored/skipped the read only variable MM.ERRNO will 
be set to non zero and MM.ERRMSG$ will be set to the error message that would 
normally be generated. These are reset to zero and an empty string by ON ERROR 
CLEAR. They are also cleared when the program is run and when ON ERROR IGNORE 
and ON ERROR SKIP are used. 
ON ERROR IGNORE can make it very difficult to debug a program so it is strongly 
recommended that only ON ERROR SKIP be used. 

``ON GOTO
ON nbr GOTO | GOSUB target[,target, target,...] 

ON either branches (GOTO) or calls a subroutine (GOSUB) based on the rounded 
value of 'nbr'; 
if it is 1, the first target is called, 
if 2, the second target is called, etc. 
Target can be a line number or a label. 

``ON KEY
ON KEY target 

Setup an interrupt which will call 'target' user defined subroutine whenever 
there is one or more characters waiting in the serial console input buffer. 
Note that all characters waiting in the input buffer should be read in the 
interrupt subroutine otherwise another interrupt will be automatically generated 
as soon as the program returns from the interrupt. 
To disable this interrupt, use numeric zero for the target, ie: ON KEY 0 

``OPEN
OPEN comspec$ AS [#]fnbr 

Will open a serial communications port for reading and writing. 
Two ports are available (COM1: and COM2:) and both can be open simultaneously. 
Using ‘fnbr’ the port can be written to and read from using any command or 
function that uses a file number. 

``OPTION AUTORUN
OPTION AUTORUN OFF | ON 

Instruct MMBasic to automatically run the program stored in flash when it starts 
up or is restarted by the WATCHDOG command. 
This is turned off by the NEW command but other commands that might change 
program memory (EDIT, etc) do not change this setting. 
Entering the break key (default CTRL-C) at the console will interrupt the 
running program and return to the command prompt. 

``OPTION BASE
OPTION BASE 0 | 1 

Set the lowest value for array subscripts to either 0 or 1. 
This must be used before any arrays are declared and is reset to the default of 
0 on power up. 

``OPTION BAUDRATE
OPTION BAUDRATE nbr 

Set the baud rate for the console to 'nbr'. This change is made immediately and 
will be remembered even when the power is cycled. The baud rate should be 
limited to the speeds listed in Appendix A for COM1. 
Using this command it is possible to set the console to an unworkable baud rate 
and in this case MMBasic should be reset as described in the chapter "Resetting 
MMBasic". This will reset the baud rate to the default of 38400 

``OPTION BREAK
OPTION BREAK nn 

Set the value of the break key to the ASCII value 'nn'. 
This key is used to interrupt a running program. 
The value of the break key is set to CTRL-C key at power up but it can be 
changed to any keyboard key using this command (for example, OPTION BREAK 4 will 
set the break key to the CTRL-D key). 
Setting this option to zero will disable the break function entirely. 

``OPTION CASE
OPTION CASE UPPER | LOWER | TITLE 

Change the case used for listing command and function names when using the LIST 
command. 
The default is TITLE but the old standard of MMBasic can be restored using 
OPTION CASE UPPER. 
This option will be remembered even when the power is removed. 

``OPTION CLOCKTRIM
OPTION CLOCKTRIM ±n 

Trim the frequency of the internal oscillator on the 28 and 44-pin Micromites. 
This oscillator is used as the basis for all timing (eg, date, time, pause, PWM 
frequency, serial baudrate, etc). 
'n' is the trim value which can range from -31 to +31 (this equates to an 
adjustment range of about -12.5% to +12.5%). On power up the trim value is zero. 
Note that this will also affect the console baudrate and an excessive trim value 
could make it impossible to communicate with the Micromite. 

``OPTION COLOURCODE
OPTION COLOURCODE ON | OFF 

Turn on or off colour coding for the editor's output. Keywords will be in cyan, 
numbers in red, etc. The default is off. 
Notes: 
 This setting is saved in flash memory and is applied on startup. 
 Colour coding requires a terminal emulator that can interpret the 
appropriate escape codes. It works correctly with Tera Term however Putty needs 
its default background colour to be changed to white. 
 If colour coding is used it is recommended that the baud rate for the 
serial console be set to a high speed. 
 The keyword COLORCODE (USA spelling) can also be used. 

``OPTION CONSOLE
OPTION CONSOLE ECHO | NOECHO | INVERT | NOINVERT | AUTO 

Used to set options for the console serial port. 
NOECHO will turn off the echoing of characters received at the console. 
ECHO will re enable the echo. The default is ECHO at bootup and the option is 
reset to ECHO whenever the program returns to the command prompt. This option is 
useful when the console is used as a third general purpose serial port. 
INVERT will invert the data polarity on both the console transmit and receive 
lines. This allows the console to be used with RS232 signals without aconverter 
(see the chapter "Low Cost RS-232 Interface" in Appendix A). It 
also allows the use of a PICAXE style programming cable. 
NOINVERT will restore the console to its normal operation and is the default. 
AUTO will automatically invert the data polarity on the console depending on the 
signal level at power up (a low input means that the console will be inverted). 
This will automatically switch between TTL serial and RS232 
serial input. Note that there is a 200mS startup delay when AUTO is used. 
This option will be remembered even when the power is removed. 

``OPTION DEFAULT
OPTION DEFAULT FLOAT | INTEGER | STRING | NONE 

Used to set the default type for a variable which is not explicitly defined. 
If OPTION DEFAULT NONE is used then all variables must have their type 
explicitly defined. 
When a program is run the default is set to FLOAT for compatibility with 
previous versions of MMBasic. 

``OPTION DISPLAY
OPTION DISPLAY lines [,chars] 

Set the characteristics of the display terminal used for the console. 
Both the LIST and EDIT commands need to know this information to correctly 
format the text for display. 
'lines' is the number of lines on the display and 'chars' is the width of the 
display in characters. The default is 24 lines x 80 chars and when changed this 
option will be remembered even when the power is removed. 
Note that the documentation for the VT100 ASCII Video Terminal initially listed 
incorrect specifications for the composite video. If you are using this project 
with the Micromite check the website http://geoffg.net/terminal.html 
for the correct specifications. 

``OPTION EXPLICIT
OPTION EXPLICIT 

Placing this command at the start of a program will require that every variable 
be explicitly declared using the DIM command before it can be used in the 
program. 
This option is disabled by default when a program is run. If it is used it must 
be specified before any variables are used. 

``OPTION LCDPANEL
OPTION LCDPANEL ILI9341, orientation, D/C pin, reset pin [,CS pin] 
or 
OPTION LCDPANEL DISABLE 

Configures the Micromite and Micromite Plus to work with an attached LCD panel 
using the ILI9341controller. 
'orientation' can be LANDSCAPE, PORTRAIT, RLANDSCAPE or RPORTRAIT. These can be 
abbreviated to L, P, RL or RP. The R prefix indicates the reverse or "upside 
down" orientation. 
'C/D pin' and 'reset pin' are the Micromite I/O pins to be used for these 
functions. Any free pin can be used. 'CS pin' can also be any I/O pin but is 
optional. If a touch controller is not used this parameter can be left off the 
command and the CS pin on the LCD display wired permanently to ground. If the 
touch controller is used this pin must then be specified and connected to a 
Micromite I/O pin. 
NOTE: The CPU speed must be 20MHz or greater. 

``OPTION LIST
OPTION LIST 

This will list the settings of any options that have been changed from their 
default setting and are the type that is saved in flash. This command is useful 
when configuring options that reserve I/O pins (ie, OPTION LCDPANEL or 
OPTION TOUCH) and you need to know what pins are in use. 

``OPTION PIN
OPTION PIN nbr 

Set 'nbr' as the PIN (Personal Identification Number) for access to the console 
prompt. 'nbr' can be any non zero number of up to eight digits. 
Whenever a running program tries to exit to the command prompt for whatever 
reason MMBasic will request this number before the prompt is presented. This is 
a security feature as without access to the command prompt an intruder cannot 
list or change the program in memory or modify the operation of MMBasic in any 
way. To disable this feature enter zero for the PIN number (ie, OPTION PIN 0). 
A permanent lock can be applied by using 99999999 for the PIN number. 
If a permanent lock is applied or the PIN number is lost the only way to recover 
is to reset MMBasic as described in the chapter "Resetting MMBasic" (this will 
also erase the program memory) 

``OPTION RESET
OPTION RESET 

Reset all saved options (including the PIN) to the default values. 

``OPTION TAB
OPTION TAB 2 | 4 | 8 

Set the spacing for the tab key. Default is 2. 
This option will be remembered even when the power is removed. 

``OPTION TOUCH
OPTION TOUCH T_CS pin, T_IRQ pin 
or 
OPTION TOUCH DISABLE 

Configures MMBasic for the touch sensitive feature of an attached LCD panel. 
'T_CS pin' and 'T_IRQ pin' are the Micromite I/O pins to be used for chip select 
and touch interrupt respectively (any free pins can be used). 

``PAUSE
PAUSE delay 

Halt execution of the running program for ‘delay’ mS. 
This can be a fraction. For example, 0.2 is equal to 200 µS. 
The maximum delay is 2147483647 mS (about 24 days). 
Note that interrupts will be recognised and processed during a pause. 

``PEEK
PEEK(BYTE addr%) 
or 
PEEK(WORD addr%) 
or 
PEEK(VARADDR var) 
or 
PEEK(CFUNADDR cfun) 
or 
PEEK(VAR var, ±offset) 
or 
PEEK( VARTBL, ±offset) 
or 
PEEK( PROGMEM, ±offset) 

Will return a byte or a word within the PIC32 virtual memory space. 
BYTE will return the byte (8-bits) located at 'addr%' 
WORD will return the word (32-bits) located at 'addr%' 
VARADDR will return the address (32-bits) of the variable 'var' in memory. 
An array is specified as var(). 
CFUNADDR will return the address (32-bits) of the CFunction 'cfun' in memory. 
This address can be passed to another CFunction which can then call it to 
perform some common process. 
VAR, will return a byte in the memory allocated to 'var'. An array is specified 
as var(). 
VARTBL, will return a byte in the memory allocated to the variable table 
maintained by MMBasic. Note that there is a comma after the keyword VARTBL. 
PROGMEM, will return a byte in the memory allocated to the program. 
Note that there is a comma after the keyword PROGMEM. 
Note that 'addr%' should be an integer. 
For backwards compatibility PEEK( hiword, loword ) is still accepted. In this 
case the address is specifies by ‘hiword’ which is the top 16 bits of the 
address while ‘loword’ is the bottom 16 bits. 
This command is for expert users only. The PIC32 maps all control registers, 
flash (program) memory and volatile (RAM) memory into a single address space so 
there is no need for INP or OUT commands. The PIC32MX170 Family Data Sheet lists 
the details of this address space (RAM starts at 0xA0000000, Program Flash 
starts at 0x9D000000 and Boot Flash starts at 0x9FC00000). 

``PI
PI 

Returns the value of pi 

``PIN
PIN( pin ) = value 

For a ‘pin’ configured as digital output this will set the output to low 
(‘value’ is zero) or high (‘value’ non-zero). You can set an output high or low 
before it is configured as an output and that setting will be the default output 
when the SETPIN command takes effect. 

When used as function PIN( pin ) returns the value on the external I/O ‘pin’. 
Zero means digital low, 1 means digital high and for analogue inputs it will 
return the measured voltage as a 
floating point number. 
Frequency inputs will return the frequency in Hz. A period input will return the 
period in milliseconds while a count input will return the count since reset 
(counting is done on the positive rising edge). The count input can be reset to 
zero by resetting the pin to counting input (even if it is already so 
configured). 
This function will also return the state of a pin configured as an output. 
Also see the SETPIN command. 

``PIXEL
PIXEL x, y [,c] 

Set a pixel on an attached LCD panel to a colour. 
'x' is the horizontal coordinate and 'y' is the vertical coordinate of the 
pixel. 
'c' is a 24 bit number specifying the colour. 
'c' is optional and if omitted the current foreground colour will be used. 
See the chapter "Basic Drawing Commands" for a definition of the colours and 
graphics coordinates. 

``POKE
POKE BYTE addr%, byte 
or 
POKE WORD addr%, word% 
or 
POKE VAR var, offset, byte 
or 
POKE VARTBL, offset, byte 

Will set a byte or a word within the PIC32 virtual memory space. 
POKE BYTE will set the byte (ie, 8 bits) at the memory location 'addr%' to 
'byte'. 'addr%' should be an integer. 
POKE WORD will set the word (ie, 32 bits) at the memory location 'addr%' to 
'word%'. 'addr%' and 'word%' should be integers. 
POKE VAR will set a byte in the memory address of 'var'. 'offset' is the ±offset 
from the address of the variable. An array is specified as var(). 
POKE VARTBL will set a byte in MMBasic's variable table. 'offset' is the ±offset 
from the start of the variable table. Note that a comma is required after the 
keyword VARTBL. 
For backwards compatibility the old form of POKE hiword, loword, val is still 
accepted. In this case the address is specified by ‘hiword’ which is thetop 16 
bits of the address while ‘loword’ is the bottom 16 bits. 
This command is for expert users only. The PIC32 maps all control registers, 
flash (program) memory and volatile (RAM) memory into a single address space so 
there is no need for INP or OUT commands. The PIC32 
Data Sheet lists the details of this address space (RAM starts at 0xA0000000). 

``PORT
PORT(start, nbr [,start, nbr]…) = value 
PORT(start, nbr [,start, nbr]…) 

Set a number of I/O pins simultaneously (ie, with one command). 
'start' is an I/O pin number and the lowest bit in 'value' (bit 0) will be used 
to set that pin. 
Bit 1 will be used to set the pin 'start' plus 1, bit 2 will set pin 'start'+2 
and so on for 'nbr' number of bits. I/O pins used must be numbered consecutively 
and any I/O pin that is invalid or not configured as an output will cause an 
error. The start/nbr pair can be repeated if an additional group of output pins 
needed to be added. 
For example; PORT(15, 4, 23, 4) = &B10000011 
Will set eight I/O pins. Pins 15 and 16 will be set high while 17, 18, 23, 24 
and 25 will be set to a low and finally 26 will be set high. 
This command can be used to conveniently communicate with parallel devices like 
LCD displays. Any number of I/O pins (and therefore bits) can be used from 1 to 
the number of I/O pins on the chip. 

When used as function PORT(start, nbr [,start, nbr]…) returns the value of a 
number of I/O pins in one operation. 
'start' is an I/O pin number and its value will be returned as bit 0. 'start'+1 
will be returned as bit 1, 'start'+2 will be returned as bit 2, and so on for 
'nbr' number of bits. I/O pins used must be numbered consecutively and any I/O 
pin that is invalid or not configured as an input will cause an error. The 
start/nbr pair can be repeated if an additional group of input pins need to be 
added. 
This function will also return the state of a pin configured as an output. It 
can be used to conveniently communicate with parallel devices like memory chips. 
Any number of I/O pins (and therefore bits) can be used from 1 to the number of 
I/O pins on the chip. 

``POS
POS 

Returns the current cursor position in the line in characters. 

``PRINT
? (question mark) 
PRINT 
PRINT expression 
[[,; ]expression] ... etc 
PRINT #nbr, expression 
[[,; ]expression] ... etc 

? (question mark) is shortcut for the PRINT command. 

Outputs text to the (serial) console. Multiple expressions can be used and must 
be separated by either a: 
- Comma (,) which will output the tab character 
- Semicolon (;) which will not output anything (it is just used to separate 
expressions). 
- Nothing or a space which will act the same as a semicolon. 
A semicolon (;) at the end of the expression list will suppress the automatic 
output of a carriage return/ newline at the end of a print statement. 
When printed, a number is preceded with a space if positive or a minus (-) if 
negative but is not followed by a space. Integers (whole numbers) are printed 
without a decimal point while fractions are printed with the decimal point and 
the significant decimal digits. Large floating point numbers (greater than six 
digits) are printed in scientific number format. 

The function TAB() can be used to space to a certain column and the string 
functions can be used to justify or otherwise format strings. 

Same as above except that the output is directed to a serial communications port 

previously opened as ‘nbr’. See the OPEN command. 

``PULSE
PULSE pin, width 

Will generate a pulse on 'pin' with duration of 'width' mS. 'width' can be a 
fraction. For example, 0.01 is equal to 10µS and this enables the generation of 
very narrow pulses. The minimum is 5 µS at 40 MHz to 40 µS at 5 MHz. 
The generated pulse is of the opposite polarity to the state of the I/O pin when 
the command is executed. For example, if the output is set high the PULSE 
command will generate a negative going pulse. 
Notes: 
 'pin' must be configured as an output. 
 For a pulse of less than 3 mS the accuracy is ± 1 µS. 
 For a pulse of 3 mS or more the accuracy is ± 0.5 mS. 
 A pulse of 3 mS or more will run in the background. Up to five different and 
concurrent pulses can be running in the background and each can have its time 
changed by issuing a new PULSE command or it can be terminated by issuing a 
PULSE command with zero for 'width'. 

``PULSIN
PULSIN( pin, polarity ) 
or 
PULSIN( pin, polarity, t1 ) 
or 
PULSIN( pin, polarity, t1, t2 ) 

Measures the width of an input pulse from 1µS to 1 second with 0.1µS resolution. 
'pin' is the I/O pin to use for the measurement, it must be previously 
configured as a digital input. 'polarity' is the type of pulse to measure, if 
zero the function will return the width of the next negative pulse, if non zero 
it will measure the next positive pulse. 
't1' is the timeout applied while waiting for the pulse to arrive, 't2' is the 
timeout used while measuring the pulse. Both are in microseconds (µS) and are 
optional. If 't2' is omitted the value of 't1' will be used for both timeouts. 
If both 't1' and 't2' are omitted then the timeouts will be set at 100000 (ie, 
100mS). 
This function returns the width of the pulse in microseconds (µS) or -1 if a 
timeout has occurred. With a CPU speed of 40MHz the measurement is accurate to 
±0.5% and ±0.5µS. At other speeds the measurement is slightly less accurate. 
Note that this function will cause the running program to pause while the 
measurement is made and interrupts will be ignored during this period. 

``PWM
PWM 1, freq, 1A 
or 
PWM 1, freq, 1A, 1B 
or 
PWM 1, freq, 1A, 1B, 1C 
or 
PWM 2, freq, 2A 
or 
PWM 2, freq, 2A, 2B 
or 
PWM channel, STOP 

Generate a pulse width modulated (PWM) output for driving analogue circuits, 
sound output, etc. 
There are a total of five outputs designated as PWM in the diagrams on pages 6 
and 7 (they are also used for the SERVO command). 
Controller 1 can have one, two or three outputs while controller 2 can have one 
or two outputs. 
Both controllers are independent and can be turned on and off and have different 
frequencies. 
'1' or '2' is the controller number and ‘freq’ is the output frequency (between 
20 Hz and 500 kHz). 
1A, 1B and 1C are the duty cycle for each of the controller 1 outputs while 2A 
and 2B are the duty cycle for the controller 2 outputs. 
The specified I/O pins will be automatically configured as outputs while any 
others will be unaffected and can be used for other duties. 
The duty cycle for each output is independent of the others and is specified as 
a percentage. If it is close to zero the output will be a narrow positive pulse, 
if 50 a square wave will be generated and if close to 100 it will be a 
very wide positive pulse. For frequencies below 25 kHz the duty cycle will be 
accurate to 0.1%. 
The output will run continuously in the background while the program is running 
and can be stopped using the STOP command. The frequency and duty cycle can be 
changed at any time (without stoping the output) by 
issuing a new PWM command. 
The PWM function will take control of any specified outputs and when stopped the 
pins will be returned to a high impedance "not configured" state. 

``RAD
RAD( degrees ) 

Converts 'degrees' to radians. 

``RANDOMIZE 
RANDOMIZE nbr 

Seed the random number generator with ‘nbr’. 
On power up the random number generator is seeded with zero and will generate 
the same sequence of random numbers each time. To generate a different random 
sequence each time you must use a different value for ‘nbr’ 
(the TIMER function is handy for that). 

``RBOX
RBOX x1, y1, w, h [, r] [,c] [,fill] 

Draws a box with rounded corners on an attached LCD panel starting at 'x1' and 
'y1' which is 'w' pixels wide and 'h' pixels high. 
'r' is the radius of the corners of the box. It defaults to 10. 
'c' specifies the colour and defaults to the default foreground colour if not 
specified. 
'fill' is the fill colour. It can be omitted or set to -1 in which case the box 
will not be filled. 

``READ
READ variable[, variable]... 

Reads values from DATA statements and assigns these values to the named 
variables. Variable types in a READ statement must match the data types in DATA 
statements as they are read. See also DATA and RESTORE. 

``REM
REM string 

REM allows remarks to be included in a program. 
Note the Microsoft style use of the single quotation mark to denote remarks is 
also supported and is preferred. 

``RESTORE
RESTORE [line] 

Resets the line and position counters for the READ statement. 
If ‘line’ is specified the counters will be reset to the beginning of the 
specified line. ‘line’ can be a line number or label. 
If ‘line’ is not specified the counters will be reset to the start of the 
program. 

``RETURN
RETURN 

RETURN concludes a subroutine called by GOSUB and returns to the statement after 
the GOSUB. 

``RGB
RGB(red, green, blue) 
or 
RGB(shortcut) 

Generates an RGB true colour value. 
'red', 'blue' and 'green' represent the intensity of each colour. A value of 
zero represents black and 255 represents full intensity. 
'shortcut' allows common colours to be specified by naming them. The colours 
that can be named are white, black, blue, green, cyan, red, magenta, yellow, 
brown and gray. 
For example, RGB(red) or RGB(cyan). 

``RIGHT$
RIGHT$( string$, number-ofchars ) 

Returns a substring of ‘string$’ with ‘number-of-chars’ from the right (end) of 
the string. 

``RND
RND( number ) 

Returns a pseudo-random number in the range of 0 to 0.999999. The 'number' value 
is ignored if supplied. The RANDOMIZE command reseeds the random number 
generator. 

``RTC
RTC GETTIME 
or 
RTC SETTIME year, month, 
day, hour, minute, second 
or 
RTC SETREG reg, value 
or 
RTC GETREG reg, var 

RTC GETTIME will get the current date/time from a PCF8563, DS1307, DS3231 or 
DS3232 real time clock and set the internal MMBasic clock accordingly. The 
date/time can then be retrieved with the DATE$ and TIME$ functions. 
RTC SETTIME will set the time in the clock chip. The 'hour' be in 24 hour 
notation. 
The RTC SETREG and GETREG commands can be used to set or read the contents of 
registers within the chip. 'reg' is the register's number, 'value' is the number 
to store in the register and 'var' is a variable that will receive the 
number read from the register. These commands are not necessary for normal 
operation but they can be used to manipulate special features of the chip 
(alarms, output signals, etc). They are also useful for storing temporary 
information in the chip's battery backed RAM. 
These chips are I2C devices and must be connected to the two I2C pins with 
appropriate pullup resistors. If the I2C bus is already open the RTC command 
will use the current settings, otherwise it will temporarily open the connection 
with a speed of 100 kHz. 

``RUN
RUN 

Run the program held in flash memory. 

``SELECT CASE
SELECT CASE value 
CASE testexp [[, testexp] …] 
<statements> 
<statements> 
CASE ELSE 
<statements> 
<statements> 
END SELECT 

Executes one of several groups of statements, depending on the value of an 
expression. 
'value' is the expression to be tested. It can be a number or string variable or 
a complex expression. 
'testexp' is the value that 'exp' is to be compared against. It can be: 
 A single expression (ie, 34, "string" or PIN(4)*5) to which it may equal 
 A range of values in the form of two single expressions separated by the 
keyword "TO" (ie, 5 TO 9 or "aa" TO "cc") 
 A comparison starting with the keyword "IS" (which is optional). For example: 
IS > 5, IS <= 10. 
When a number of test expressions (separated by commas) are used the CASE 
statement will be true if any one of these tests evaluates to true. 
If 'value' cannot be matched with a 'testexp' it will be automatically matched 
to the CASE ELSE. If CASE ELSE is not present the program will not execute any 
<statements> and continue with the code following the END 
SELECT. 
When a match is made the <statements> following the CASE statement will be 
executed until END SELECT or another CASE is encountered when the program will 
then continue with the code following the END SELECT. 
An unlimited number of CASE statements can be used but there must be only one 
CASE ELSE and that should be the last before the END SELECT. 
Each SELECT CASE must have one and one only matching END SELECT statement. Any 
number of SELECT…CASE statements can be nested inside the CASE statements of 
other SELECT…CASE statements. 
Example: 
SELECT CASE nbr% 
CASE 4, 9, 22, 33 TO 88 
statements 
CASE IS < 4, IS > 88, 5 TO 8 
statements 
CASE ELSE 
statements 
END SELECT 

``SERVO
SERVO 1 [, freq], 1A 
or 
SERVO 1 [, freq], 1A, 1B 
or 
SERVO 1 [, freq], 1A, 1B, 1C 
or 
SERVO 2 [, freq], 2A 
or 
SERVO 2 [, freq], 2A, 2B 
or 
SERVO channel, STOP 

Generate a constant stream of positive going pulses for driving a servo. 
The Micromite has two servo controllers with the first being able to control up 
to three servos and the second two servos. Both controllers are independent and 
can be turned on and off and have different frequencies. 
This command uses the I/O pins that are designated as PWM in the diagrams on 
pages 6 and 7 (the two commands are very similar). 
'1' or '2' is the controller number. ‘freq’ is the output frequency (between 
20Hz and 1000 Hz) and is optional. If not specified it will default to 50 Hz 1A, 
1B and 1C are the pulse widths for each of the controller 1 outputs while 
2A and 2B are the pulse widths for the controller 2 outputs. The specified I/O 
pins will be automatically configured as outputs while any others will be 
unaffected and can be used for other duties. 
The pulse width for each output is independent of the others and is specified in 
milliseconds, which can be a fractional number (ie, 1.536). For accurate 
positioning the output resolution is about 0.005 mS. The minimum value is 0.01mS 
while the maximum is 18.9mS. Most servos will accept a range of 0.8mS to 2.2mS. 
The output will run continuously in the background while the program is running 
and can be stopped using the STOP command. The pulse widths of the outputs can 
be changed at any time (without stoping the output) by issuing a new SERVO 
command. 
The SERVO function will take control of any specified outputs and when stopped 
the pins will be returned to a high impedance "not configured" state. 

``SETPIN
SETPIN pin, cfg [, option] 
SETPIN pin, cfg, target [,option] 

Will configure an external I/O pin. 
'pin' is the I/O pin to configure 
‘cfg’ is the mode that the pin is to be set to and 'option' is an optional 
parameter. 
'cfg' is a keyword and can be any one of the following: 
OFF Not configured or inactive 
AIN Analog input (ie, measure the voltage on the input) 
DIN Digital input 
If 'option' is omitted the input will be high impedance 
If 'option' is the keyword "PULLUP" an internal resistor will be used to pull up 
the input pin to 3.3V If the keyword 
"PULLDOWN" is used the pin will be pulled down to zero volts. The value of the 
pull up or down is the equivalent of about 100K. 
FIN Frequency input 
'option' can be used to specify the gate time (the length of time used to count 
the input cycles). It can be any number between 10 mS and 100000 mS. Note that 
the PIN() function will always return the frequency correctly scaled in Hz 
regardless of the gate time used. If 'option' is omitted the gate time will be 1 
second. 
PIN Period input 
'option' can be used to specify the number of input cycles to average the period 
measurement over. It can be any number between 1 and 10000. Note that the PIN() 
function will always return the average period of one cycle correctly scaled in 
mS regardless of the number of cycles used for the average. 
If 'option' is omitted the period of just one cycle will be used. 
CIN Counting input 
DOUT Digital output 
'option' can be "OC" in which case the output will be open collector (or more 
correctly open drain). The functions PIN() and PORT() can also be used to return 
the value on one or more output pins. 
Previous versions of MMBasic used numbers for 'cfg' and the mode OOUT. 
For backwards compatibility they will still be recognised. 
See the function PIN() for reading inputs and the statement PIN()= for setting 
an output. See the command below if an interrupt is configured. 

Will configure ‘pin’ to generate an interrupt according to ‘cfg’. 
Any I/O pin capable of digital input can be configured to generate an interrupt 
with a maximum of ten interrupts configured at any one time. 
'cfg' is a keyword and can be any one of the following: 
OFF Not configured or inactive 
INTH Interrupt on low to high input 
INTL Interrupt on high to low input 
INTB Interrupt on both (ie, any change to the input) 
‘target' is a user defined subroutine which will be called when the event 
happens. Return from the interrupt is via the END SUB or EXIT SUB commands. 
If 'option' is the keyword "PULLUP" an internal resistor will be used to pullup 
the input pin to 3.3V If the keyword "PULLDOWN" is used the pin will be pulled 
down to zero volts. The pull up or down is about 100K. If 'option' 
is omitted the input will be high impedance. This mode also configures the pin 
as a digital input so the value of the pin can always be retrieved using the 
function PIN(). 

``SETTICK
SETTICK period, target [, nbr] 

This will setup a periodic interrupt (or "tick"). 
Four tick timers are available ('nbr' = 1, 2, 3 or 4). 'nbr' is optional and if 
not specified timer number 1 will be used. 
The time between interrupts is ‘period’ milliseconds and ‘target' is the 
interrupt subroutine which will be called when the timed event occurs. 
The period can range from 1 to 2147483647 mSec (about 24 days). 
These interrupts can be disabled by setting ‘period’ to zero (ie, SETTICK 0, 0, 
3 will disable tick timer number 3). 

``SGN
SGN( number ) 

Returns the sign of the argument 'number', +1 for positive numbers, 0 for 0, and 
-1 for negative numbers. 

``SIN
SIN( number ) 

Returns the sine of the argument 'number' in radians. 

``SPACE$
SPACE$( number ) 

Returns a string of blank spaces 'number' bytes long 

``SPI
The Serial Peripheral Interface (SPI) communications protocol is used to send 
and receive data between integrated circuits. The Micromite acts as the master 
(ie, it generates the clock). 

SPI OPEN speed, mode, bits 
SPI WRITE nbr, data1, data2, data3, ... etc 
SPI WRITE nbr, string$ 
SPI WRITE nbr, array() 
SPI READ nbr, array() 
SPI CLOSE 

``SPI CLOSE
SPI CLOSE 

If required the SPI channel can be closed as follows (the I/O pins will be set 
to inactive): 
``SPI OPEN
SPI Open 
To use the SPI function the SPI channel must be first opened. 
The syntax for opening the SPI channel is: 

SPI OPEN speed, mode, bits 
Where: 
 ‘speed’ is the speed of the clock. It is a number representing the clock speed 
in Hz. The maximum is 
one quarter the CPU speed (ie, 10000000 at a CPU speed of 40 MHz). 
 'mode' is a single numeric digit representing the transmission mode – see 
Transmission Format below. 
 'bits' is the number of bits to send/receive. This can be 8, 16 or 32. 
 It is the responsibility of the program to separately manipulate the CS (chip 
select) pin if required. 

``SPI READ
Data can also be received in bulk: 

SPI READ nbr, array() 

Where 'nbr' is the number of data items to be received and array() is a single 
dimension integer array where the 
received data items will be saved. This command sends zeros while reading the 
data from the slave. 
``SPI WRITE
SPI WRITE nbr, data1, data2, data3, ... etc 
or 
SPI WRITE nbr, string$ 
or 
SPI WRITE nbr, array() 

In the first method 'nbr' is the number of data items to send and the data is 
the expressions in the argument list 
(ie, 'data1', data2' etc). The data can be an integer or a floating point 
variable or a constant. 
In the second or third method listed above the data to be sent is contained in 
the 'string$' or the contents of 
'array()' (which must be a single dimension array of integer or floating point 
numbers). The string length, or the 
size of the array must be the same or greater than nbr. Any data returned from 
the slave is discarded. 
``SQR
SQR( number ) 

Returns the square root of the argument 'number'. 

``STR$
STR$( number ) 
or 
STR$( number, m ) 
or 
STR$( number, m, n ) 
or 
STR$( number, m, n, c$ ) 

Returns a string in the decimal (base 10) representation of 'number'. 
If 'm' is specified sufficient spaces will be added to the start of the number 
to ensure that the number of characters before the decimal point (including the 
negative sign) will be at least 'm' characters. If 'm' is zero or the number has 
more than 'm' significant digits no padding spaces will be added. 
If 'm' is negative positive numbers will be prefixed with the plus symbol and 
negative numbers with the minus symbol (as is normal). 
'n' is the number of digits required to follow the decimal place. The maximum 
value is seven and if 'n' is zero the string will be returned without the 
decimal point. If 'n' is not specified then the number of decimal places will 
vary according to the number. 
'c$' is a string and if specified the first character of this string will be 
used as the padding character instead of a space (see the 'm' argument). 
Examples: 
STR$(123.456) will return "123.456" 
STR$(123.456, 6) will return " 123.456" 
STR$(123.456, -6) will return " +123.456" 
STR$(-123.456, 6) will return " -123.456" 
STR$(-123.456, 6, 5) will return " -123.45600" 
STR$(53, 6) will return " 53" 
STR$(53, 6, 2) will return " 53.00" 
STR$(53, 6, 2, "*") will return "****53.00" 

``STRING$
STRING$( nbr, ascii ) 
or 
STRING$( nbr, string$ ) 

Returns a string 'nbr' bytes long consisting of either the first character of 
string$ or the character representing the ASCII value 'ascii' which is a decimal 
number in the range of 32 to 126. 

``SUB
SUB xxx (arg1 [,arg2, …]) 
<statements> 
<statements> 
END SUB 

Defines a callable subroutine. This is the same as adding a new command to 
MMBasic while it is running your program. 
'xxx' is the subroutine name and it must meet the specifications for naming a 
variable. 
'arg1', 'arg2', etc are the arguments or parameters to the subroutine. 
An array is specified by using empty brackets. ie, arg3(). 
The type of the argument can be specified by using a type suffix (ie, arg1$) or 
by specifying the type using AS <type> (ie, arg1 AS STRING). 
Every definition must have one END SUB statement. When this is reached the 
program will return to the next statement after the call to the subroutine. 
The command EXIT SUB can be used for an early exit. 
You use the subroutine by using its name and arguments in a program just as you 
would a normal command. 
For example: MySub a1, a2 
When the subroutine is called each argument in the caller is matched to the 
argument in the subroutine definition. These arguments are available only inside 
the subroutine. Subroutines can be called with a variable number of 
arguments. Any omitted arguments in the subroutine's list will be set to zero or 
a null string. 
Arguments in the caller's list that are a variable (ie, not an expression or 
constant) will be passed by reference to the subroutine. This means that any 
changes to the corresponding argument in the subroutine will also be copied 
to the caller's variable and therefore may be accessed after the subroutine has 
ended. Arrays are passed by specifying the array name with empty brackets (eg, 
arg()) and are always passed by reference. Brackets around the argument list in 
both the caller and the definition are optional. 

``TAB
TAB( number ) 

Outputs spaces until the column indicated by 'number' has been reached. 

``TAN
TAN( number ) 

Returns the tangent of the argument 'number' in radians. 

``TEMPR
TEMPR( pin ) 

Return the temperature measured by a DS18B20 temperature sensor connected to 
'pin' (which does not have to be configured). The CPU speed must be 20 MHz or 
above. 
The returned value is degrees C with a default resolution of 0.25ºC. If there is 
an error during the measurement the returned value will be 1000. 
The time required for the overall measurement is 200mS and interrupts will be 
ignored during this period. Alternatively the TEMPR START command can be used to 
start the measurement and your program can do other things while the conversion 
is progressing. When this function is called the value will then be returned 
instantly assuming the conversion period has expired. 
If it has not, this function will wait out the remainder of the conversion time 
before returning the value. 
The DS18B20 can be powered separately by a 3V to 5V supply or it can operate on 
parasitic power from the Micromite. 

``TEMPR START
TEMPR START pin [, precision] 

This command can be used to start a conversion running on a DS18B20 temperature 
sensor connected to 'pin'. Note that only a single space is allowed between 
TEMPR and START. 
Normally the TEMPR() function alone is sufficient to make a temperature 
measurement so usage of this command is optional and can be ignored. 
This command will start the measurement on the temperature sensor. The program 
can then attend to other duties while the measurement is running and later use 
the TEMPR() function to get the reading. If the TEMPR() function is used before 
the conversion time has completed the function will wait for the remaining 
conversion time before returning the value. 
'precision' is the resolution of the measurement and is optional. It is a number 
between 0 and 3 meaning: 
0 = 0.5ºC resolution, 100 mS conversion time. 
1 = 0.25ºC resolution, 200 mS conversion time (this is the default). 
2 = 0.125ºC resolution, 400 mS conversion time. 
3 = 0.0625ºC resolution, 800 mS conversion time. 

``TEXT
TEXT x, y, string$ [,justification] [, font] [, scale] [, c] [, bc] 

Displays a string on an attached LCD panel starting at 'x' and 'y'. 
‘string$’ is the string to be displayed. Note that numeric data can be converted 
to a string and formatted using the Str$() function. 
'justification' is one or two letters where the first letter is the horizontal 
justification around 'x' and can be L, C or R for LEFT, CENTER, RIGHT and the 
second letter is the vertical placement around 'y' and can be T, M or B for TOP, 
MIDDLE, BOTTOM. The default justification is left/top. 
'font' and 'scale' are optional and default to that set by the FONT command. 
'c' is the drawing colour and 'BC' is the background colour. They are optional 
and default to the current foreground and background colours. 

``TIME$
TIME$ = "HH:MM:SS" 
or 
TIME$ = "HH:MM" 
or 
TIME$ = "HH" 

Sets the time of the internal clock. MM and SS are optional and will default to 
zero if not specified. For example TIME$ = "14:30" will set the clock to 14:30 
with zero seconds. 
The time is set to "00:00:00" on power up. 

When used as function TIME$ returns the current time based on MMBasic's internal 
clock as a string in the 
form "HH:MM:SS" in 24 hour notation. For example, "14:30:00". 

``TIMER
TIMER = msec 

Resets the timer to a number of milliseconds. Normally this is just used to 
reset the timer to zero but you can set it to any positive integer. 

When used as function TIMER returns the elapsed time in milliseconds (eg, 1/1000 
of a second) since reset. 
The timer is reset to zero on power up or a CPU restart and you can also reset 
it by using TIMER as a command. If not specifically reset it will continue to 
count up forever (it is a 64 bit number and will only roll over to zero after 
200 million years). 

``TOUCH
TOUCH(X) 
or 
TOUCH(Y) 

Will return the X or Y coordinate of the location currently touched on an LCD 
panel. 
If the screen is not being touched the function will return -1. 

``TRACE
TRACE ON 
or 
TRACE OFF 
or 
TRACE LIST nn 

TRACE ON/OFF will turn on/off the trace facility. This facility will print the 
number of each line (counting from the beginning of the program) in square 
brackets as the program is executed. This is useful in debugging programs. 
Micromite Plus only: TRACE LIST will list the last 'nn' lines executed in the 
format described above. Note that MMBasic is always logging the lines executed 
so this facility is always available (ie, it does not have to be turned 
on). 

``UCASE$
UCASE$( string$ ) 

Returns ‘string$’ converted to uppercase characters. 

``VAL
VAL( string$ ) 

Returns the numerical value of the ‘string$’. If 'string$' is an invalid number 
the function will return zero. 
This function will recognise the &H prefix for a hexadecimal number, &O for 
octal and &B for binary. 

``VAR
VAR SAVE var [, var]… 
or 
VAR RESTORE 
or 
VAR CLEAR 

VAR SAVE will save one or more variables to non volatile flash memory where they 
can be restored later (normally after a power interruption). 
'var' can be any number of numeric or a string variables and/or arrays. 
Arrays are specified by using empty brackets. For example: var() 
VAR RESTORE will retrieve the previously saved variables and insert them (and 
their values) into the variable table. 
The VAR SAVE command can be used repeatedly. Variables that had been previously 
saved will be updated with their new value and any new variables (not previously 
saved) will be added to the saved list for later restoration. 
VAR CLEAR will erase all saved variables. Also, the saved variables will be 
automatically cleared by the NEW command or when a new program is loaded. 
This command is normally used to save calibration data, options, and other data 
which does not change often but needs to be retained across a power 
interruption. Normally the VAR RESTORE command is placed at the start 
of the program so that previously saved variables are restored and immediately 
available to the program when it starts. 
Notes: 
 The storage space available to this command is 2KB or 4KB on the Micromite 
Plus. 
 Using VAR RESTORE without a previous save will have no effect and will not 
generate an error. 
 If, when using RESTORE, a variable with the same name already exists its value 
will be overwritten. 
 Saved arrays must be declared (using DIM) before they can be restored. 
 Be aware that string arrays can rapidly use up all the memory allocated to 
this command. The LENGTH qualifier can be used when a string array is declared 
to reduce the size of the array (see the DIM command). 

``WATCHDOG
WATCHDOG timeout 
or 
WATCHDOG OFF 

Starts the watchdog timer which will automatically restart the processor when it 
has timed out. This can be used to recover from some event that disabled the 
running program (such as an endless loop or a programming or other error that 
halts a running program). This can be important in an unattended control 
situation. 
'timeout' is the time in milliseconds (mS) before a restart is forced. This 
command should be placed in strategic locations in the running BASIC program to 
constantly reset the watchdog timer and therefore prevent it from counting down 
to zero. 
If the timer count does reach zero (perhaps because the BASIC program has 
stopped running) the Micromite will be automatically restarted and the automatic 
variable MM.WATCHDOG will be set to true (ie, 1) indicating that an error 
occurred. On a normal startup MM.WATCHDOG will be set to false (ie, 0). 
At any time WATCHDOG OFF can be used to disable the watchdog timer (this is the 
default on a reset or power up). The timer is also turned off when the break 
character (normally CTRL-C) is used on the console to interrupt a running 
program. 

``XMODEM
XMODEM SEND 
or 
XMODEM RECEIVE 

Transfers a BASIC program to or from a remote computer using the XModem 
protocol. The transfer is done over the serial console connection. 
XMODEM SEND will send the current program held in the Micromite's program memory 
to the remote device. 
XMODEM RECEIVE will accept a program sent by the remote device and save it into 
the Micromite's program memory overwriting the program currently held there. 
Note that the data is buffered in RAM which limits the 
maximum program size. 
SEND and RECEIVE can be abbreviated to S and R. 
The XModem protocol requires a cooperating software program running on the 
remote computer and connected to its serial port. It has been tested on Tera 
Term running on Windows and it is recommended that this be used. 
After running the XMODEM command in MMBasic select: 
File -> Transfer -> XMODEM -> Receive/Send from the Tera Term menu to start the 
transfer. 
The transfer can take up to 15 seconds to start and if the XMODEM command fails 
to establish communications it will return to the MMBasic prompt after 60 
seconds and leave the program memory untouched. 
Download Tera Term from http://ttssh2.sourceforge.jp 

